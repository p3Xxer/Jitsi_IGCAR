/** @jsx jsx */
import { css, jsx } from '@emotion/core';
import { useGlobalTheme } from '@atlaskit/theme/components';
import { buttonWidthUnitless, defaultTextPadding, maxTextWidth, maxTextWidthUnitless, textFontSize, textMarginLeft, textPaddingRight } from '../../../constants';
import * as theme from '../../../theme';
var baseStyles = css({
  maxWidth: maxTextWidth,
  paddingTop: '2px',
  paddingRight: defaultTextPadding,
  paddingBottom: '2px',
  paddingLeft: defaultTextPadding,
  fontSize: textFontSize,
  fontWeight: 'normal',
  lineHeight: 1,
  overflow: 'hidden',
  textOverflow: 'ellipsis',
  whiteSpace: 'nowrap'
});
var linkStyles = css({
  pointerEvents: 'auto',
  textDecoration: 'none',
  '&:focus': {
    outline: 'none'
  }
});
var lightLinkStyles = css({
  '&:hover': {
    color: theme.linkHoverTextColors.light
  }
});
var darkLinkStyles = css({
  '&:hover': {
    color: theme.linkHoverTextColors.dark
  }
});
var colorfulLinkStyles = css({
  color: 'inherit',
  textDecoration: 'underline'
});
var hasAfterStyles = css({
  maxWidth: "".concat(maxTextWidthUnitless - buttonWidthUnitless, "px"),
  paddingRight: textPaddingRight
});
var hasBeforeStyles = css({
  marginLeft: textMarginLeft
});

var Content = function Content(_ref) {
  var _ref$elemBefore = _ref.elemBefore,
      elemBefore = _ref$elemBefore === void 0 ? null : _ref$elemBefore,
      _ref$isRemovable = _ref.isRemovable,
      isRemovable = _ref$isRemovable === void 0 ? true : _ref$isRemovable,
      _ref$text = _ref.text,
      text = _ref$text === void 0 ? '' : _ref$text,
      _ref$color = _ref.color,
      color = _ref$color === void 0 ? 'standard' : _ref$color,
      href = _ref.href,
      linkComponent = _ref.linkComponent;

  var _useGlobalTheme = useGlobalTheme(),
      mode = _useGlobalTheme.mode;

  var Link = linkComponent !== null && linkComponent !== void 0 ? linkComponent : 'a';

  if (href) {
    return jsx(Link, {
      href: href,
      "data-color": color,
      css: [baseStyles, linkStyles, mode === 'light' && lightLinkStyles, mode === 'dark' && darkLinkStyles, color !== 'standard' && colorfulLinkStyles, elemBefore && hasBeforeStyles, isRemovable && hasAfterStyles]
    }, text);
  } else {
    return jsx("span", {
      css: [baseStyles, elemBefore && hasBeforeStyles, isRemovable && hasAfterStyles]
    }, text);
  }
};

export default Content;