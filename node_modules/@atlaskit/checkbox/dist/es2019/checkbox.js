import _extends from "@babel/runtime/helpers/extends";

/**  @jsx jsx */
import { forwardRef, memo, useCallback, useMemo, useState } from 'react';
import { jsx } from '@emotion/core';
import { usePlatformLeafEventHandler } from '@atlaskit/analytics-next/usePlatformLeafEventHandler';
import GlobalTheme from '@atlaskit/theme/components';
import { getCheckboxStyles, Label, LabelText, RequiredIndicator } from './internal';
import { name as packageName, version as packageVersion } from './version.json';
const sizes = {
  small: '16',
  medium: '24',
  large: '32',
  xlarge: '48'
}; // An svg is used so we don't pull in styled-components as well as
// a wrapping span. This approach is more performant.

const CheckboxIcon = /*#__PURE__*/memo(({
  size,
  isIndeterminate
}) => jsx("svg", {
  width: sizes[size],
  height: sizes[size],
  viewBox: "0 0 24 24"
}, jsx("g", {
  fillRule: "evenodd"
}, jsx("rect", {
  fill: "currentColor",
  x: "6",
  y: "6",
  width: "12",
  height: "12",
  rx: "2"
}), isIndeterminate ? jsx("rect", {
  fill: "inherit",
  x: "8",
  y: "11",
  width: "8",
  height: "2",
  rx: "1"
}) : jsx("path", {
  d: "M9.707 11.293a1 1 0 1 0-1.414 1.414l2 2a1 1 0 0 0 1.414 0l4-4a1 1 0 1 0-1.414-1.414L11 12.586l-1.293-1.293z",
  fill: "inherit"
}))));
const CheckboxWithMode = /*#__PURE__*/forwardRef(function Checkbox(props, ref) {
  const {
    isChecked: isCheckedProp,
    isDisabled = false,
    isInvalid = false,
    defaultChecked = false,
    isIndeterminate = false,
    size = 'medium',
    onChange: onChangeProps,
    analyticsContext,
    label,
    mode,
    name,
    value,
    isRequired,
    testId,
    ...rest
  } = props;
  const [isCheckedState, setIsCheckedState] = useState(isCheckedProp !== undefined ? isCheckedProp : defaultChecked);
  const onChange = useCallback((e, analyticsEvent) => {
    setIsCheckedState(e.target.checked);

    if (onChangeProps) {
      onChangeProps(e, analyticsEvent);
    }
  }, [onChangeProps]);
  const onChangeAnalytics = usePlatformLeafEventHandler({
    fn: onChange,
    action: 'changed',
    analyticsData: analyticsContext,
    componentName: 'checkbox',
    packageName,
    packageVersion
  }); // Use isChecked from the state if it is controlled

  const isChecked = isCheckedProp === undefined ? isCheckedState : isCheckedProp; // The styles are being generated for the input but are being
  // applied to the svg with a sibling selector so we have access
  // to the pseudo-classes of the input

  const styles = useMemo(() => getCheckboxStyles(mode), [mode]);
  return jsx(Label, {
    isDisabled: isDisabled,
    testId: testId && `${testId}--checkbox-label`
  }, jsx("input", _extends({}, rest, {
    type: "checkbox",
    ref: ref,
    disabled: isDisabled,
    checked: isChecked,
    value: value,
    name: name,
    required: isRequired,
    css: styles,
    onChange: onChangeAnalytics,
    "aria-checked": isIndeterminate ? 'mixed' : isChecked,
    "data-testid": testId && `${testId}--hidden-checkbox`,
    "data-invalid": isInvalid ? 'true' : undefined
  })), jsx(CheckboxIcon, {
    size: size,
    isIndeterminate: isIndeterminate
  }), jsx(LabelText, null, label, isRequired && jsx(RequiredIndicator, {
    "aria-hidden": "true"
  })));
});
export const Checkbox = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function Checkbox(props, ref) {
  return jsx(GlobalTheme.Consumer, null, ({
    mode
  }) => jsx(CheckboxWithMode, _extends({}, props, {
    ref: ref,
    mode: mode
  })));
}));
Checkbox.displayName = 'Checkbox';
export default Checkbox;