"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitClassNamesPath = void 0;
var t = __importStar(require("@babel/types"));
var css_1 = require("@compiled/css");
var ast_1 = require("../utils/ast");
var ast_builders_1 = require("../utils/ast-builders");
var css_builders_1 = require("../utils/css-builders");
/**
 * Handles style prop value. If variables are present it will replace its value with it
 * otherwise will add undefined.
 *
 * @param variables CSS variables prop to be placed as inline styles
 * @param path Any Expression path
 */
var handleStyleProp = function (variables, path) {
    var styleValue = variables.length
        ? t.objectExpression(ast_builders_1.buildCssVariablesProp(variables))
        : t.identifier('undefined');
    path.replaceWith(styleValue);
};
/**
 * Extracts styles from an expression.
 *
 * @param path Expression node
 */
var extractStyles = function (path) {
    var _a;
    if (t.isCallExpression(path.node) &&
        t.isIdentifier(path.node.callee) &&
        path.node.callee.name === 'css' &&
        t.isExpression(path.node.arguments[0])) {
        // css({}) call
        var styles = path.node.arguments;
        return styles;
    }
    if (t.isCallExpression(path.node) &&
        t.isIdentifier(path.node.callee) &&
        t.isExpression(path.node.arguments[0]) &&
        path.scope.hasOwnBinding(path.node.callee.name)) {
        var binding = (_a = path.scope.getBinding(path.node.callee.name)) === null || _a === void 0 ? void 0 : _a.path.node;
        if (!!ast_1.resolveIdentifierComingFromDestructuring({ name: 'css', node: binding })) {
            // c({}) rename call
            var styles = path.node.arguments;
            return styles;
        }
    }
    if (t.isCallExpression(path.node) && t.isMemberExpression(path.node.callee)) {
        if (t.isIdentifier(path.node.callee.property) &&
            path.node.callee.property.name === 'css' &&
            t.isExpression(path.node.arguments[0])) {
            // props.css({}) call
            var styles = path.node.arguments;
            return styles;
        }
    }
    if (t.isTaggedTemplateExpression(path.node)) {
        var styles = path.node.quasi;
        return styles;
    }
    return undefined;
};
/**
 * Returns the children of a children as function expression.
 * Will throw if no children as function was found.
 *
 * @param path
 */
var getJsxChildrenAsFunction = function (path) {
    var children = path.node.children.find(function (node) { return t.isJSXExpressionContainer(node); });
    if (t.isJSXExpressionContainer(children) && t.isFunction(children.expression)) {
        return children.expression;
    }
    throw ast_1.buildCodeFrameError("ClassNames children should be a function\nE.g: <ClassNames>{props => <div />}</ClassNames>", path.node, path);
};
/**
 * Takes a class name component and transforms it into a compiled component.
 * This method will traverse the AST twice,
 * once to replace all calls to `css`,
 * and another to replace `style` usage.
 *
 * `<ClassNames>{}</ClassNames>`
 *
 * @param path Babel path - expects to be a JSX opening element.
 * @param state Babel state - should house options and meta data used during the transformation.
 */
var visitClassNamesPath = function (path, meta) {
    var _a;
    if (t.isJSXIdentifier(path.node.openingElement.name) &&
        path.node.openingElement.name.name !== ((_a = meta.state.compiledImports) === null || _a === void 0 ? void 0 : _a.ClassNames)) {
        // We aren't interested in this element. Bail out!
        return;
    }
    var collectedVariables = [];
    var collectedSheets = [];
    // First pass to replace all usages of `css({})`
    path.traverse({
        Expression: function (path) {
            var styles = extractStyles(path);
            if (!styles) {
                // Nothing to do - skip.
                return;
            }
            var builtCss = css_builders_1.buildCss(styles, meta);
            var _a = css_1.transformCss(builtCss.css.map(function (x) { return css_builders_1.getItemCss(x); }).join('')), sheets = _a.sheets, classNames = _a.classNames;
            collectedVariables.push.apply(collectedVariables, builtCss.variables);
            collectedSheets.push.apply(collectedSheets, sheets);
            path.replaceWith(t.stringLiteral(classNames.join(' ')));
        },
    });
    // Second pass to replace all usages of `style`.
    path.traverse({
        Expression: function (path) {
            var _a;
            if (t.isIdentifier(path.node)) {
                if (path.parentPath.isProperty()) {
                    return;
                }
                // style={style}
                if (path.node.name === 'style' && path.scope.hasOwnBinding('style')) {
                    handleStyleProp(collectedVariables, path);
                }
                // style={styl} rename prop
                if (path.scope.hasOwnBinding(path.node.name)) {
                    var binding = (_a = path.scope.getBinding(path.node.name)) === null || _a === void 0 ? void 0 : _a.path.node;
                    if (!!ast_1.resolveIdentifierComingFromDestructuring({
                        name: 'style',
                        node: binding,
                    })) {
                        handleStyleProp(collectedVariables, path);
                    }
                }
            }
            else if (t.isMemberExpression(path.node)) {
                // filter out invalid calls like dontexist.style
                if (t.isIdentifier(path.node.object) && !path.scope.hasOwnBinding(path.node.object.name)) {
                    return;
                }
                // style={props.style}
                if (t.isIdentifier(path.node.property) && path.node.property.name === 'style') {
                    handleStyleProp(collectedVariables, path);
                }
            }
        },
    });
    // All done! Pick the children as function body and replace the original ClassNames node with it.
    var children = getJsxChildrenAsFunction(path);
    var body = ast_1.pickFunctionBody(children);
    path.replaceWith(ast_builders_1.compiledTemplate(body, collectedSheets, meta));
};
exports.visitClassNamesPath = visitClassNamesPath;
//# sourceMappingURL=index.js.map