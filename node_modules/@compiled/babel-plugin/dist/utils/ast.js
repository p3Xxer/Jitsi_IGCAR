"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pickFunctionBody = exports.wrapNodeInIIFE = exports.resolveBindingNode = exports.resolveIdentifierComingFromDestructuring = exports.tryEvaluateExpression = exports.isPathReferencingAnyMutatedIdentifiers = exports.getKey = exports.getValueFromObjectExpression = exports.getMemberExpressionMeta = exports.buildCodeFrameError = exports.getPathOfNode = void 0;
var t = __importStar(require("@babel/types"));
var traverse_1 = __importDefault(require("@babel/traverse"));
var parser_1 = require("@babel/parser");
var fs_1 = __importDefault(require("fs"));
var path_1 = __importDefault(require("path"));
var resolve_1 = __importDefault(require("resolve"));
/**
 * Returns the nodes path including the scope of a parent.
 * @param node
 * @param parentPath
 */
var getPathOfNode = function (node, parentPath) {
    var foundPath = null;
    traverse_1.default(t.expressionStatement(node), {
        enter: function (path) {
            foundPath = path;
            path.stop();
        },
    }, parentPath.scope, undefined, parentPath);
    if (!foundPath) {
        throw parentPath.buildCodeFrameError('No path for a child node was found.');
    }
    return foundPath;
};
exports.getPathOfNode = getPathOfNode;
/**
 * Builds a code frame error from a passed in node.
 *
 * @param error
 * @param node
 * @param parentPath
 */
var buildCodeFrameError = function (error, node, parentPath) {
    if (!node) {
        throw parentPath.buildCodeFrameError(error);
    }
    var startLoc = node.loc ? " (" + node.loc.start.line + ":" + node.loc.start.column + ")" : '';
    return exports.getPathOfNode(node, parentPath).buildCodeFrameError("" + error + startLoc + ".");
};
exports.buildCodeFrameError = buildCodeFrameError;
/**
 * Returns the binding identifier for a member expression.
 *
 * For example:
 * 1. Member expression `foo.bar.baz` will return the `foo` identifier along
 * with `originalBindingType` as 'Identifier'.
 * 2. Member expression with function call `foo().bar.baz` will return the
 * `foo` identifier along with `originalBindingType` as 'CallExpression'.
 *
 * @param expression - Member expression node.
 */
var getMemberExpressionMeta = function (expression) {
    var accessPath = [];
    var bindingIdentifier = null;
    var originalBindingType = 'Identifier';
    if (t.isIdentifier(expression.property)) {
        accessPath.push(expression.property);
    }
    traverse_1.default(t.expressionStatement(expression), {
        noScope: true,
        MemberExpression: function (path) {
            if (t.isIdentifier(path.node.object)) {
                bindingIdentifier = path.node.object;
                originalBindingType = bindingIdentifier.type;
            }
            else if (t.isCallExpression(path.node.object)) {
                if (t.isIdentifier(path.node.object.callee)) {
                    bindingIdentifier = path.node.object.callee;
                    originalBindingType = path.node.object.type;
                }
            }
            if (t.isIdentifier(path.node.property)) {
                accessPath.push(path.node.property);
            }
        },
    });
    return {
        accessPath: accessPath.reverse(),
        bindingIdentifier: bindingIdentifier,
        originalBindingType: originalBindingType,
    };
};
exports.getMemberExpressionMeta = getMemberExpressionMeta;
/**
 * Will return the value of a path from an object expression.
 *
 * For example if  we take an object expression that looks like:
 * ```
 * { colors: { primary: 'red' } }
 * ```
 *
 * And a path of identifiers that looks like:
 * ```
 * [colors, primary]
 * ```
 *
 * Would result in returning the `red` string literal node.
 * If the value is not found `undefined` will be returned.
 *
 * @param expression - Member expression node.
 * @param accessPath - Access path identifiers.
 */
var getValueFromObjectExpression = function (expression, accessPath) {
    var value = undefined;
    traverse_1.default(expression, {
        noScope: true,
        ObjectProperty: function (path) {
            if (t.isIdentifier(path.node.key, { name: accessPath[0].name })) {
                if (t.isObjectExpression(path.node.value)) {
                    value = exports.getValueFromObjectExpression(path.node.value, accessPath.slice(1));
                }
                else {
                    value = path.node.value;
                }
                path.stop();
            }
        },
    });
    return value;
};
exports.getValueFromObjectExpression = getValueFromObjectExpression;
/**
 * Will return either the name of an identifier or the value of a string literal.
 *
 * E.g:
 * - `foo` identifier node will return `"foo"`,
 * - `"bar"` string literal node will return `"bar"`.
 *
 * @param node
 */
var getKey = function (node) {
    if (t.isIdentifier(node)) {
        return node.name;
    }
    if (t.isStringLiteral(node)) {
        return node.value;
    }
    throw new Error(node.type + " has no name.'");
};
exports.getKey = getKey;
/**
 * Returns `true` if an identifier or any paths that reference the identifier are mutated.
 * @param path
 */
var isIdentifierReferencesMutated = function (path) {
    var binding = path.scope.getBinding(path.node.name);
    if (!binding) {
        return false;
    }
    if (!t.isVariableDeclarator(binding.path.node) || !binding.constant) {
        return true;
    }
    for (var i = 0; i < binding.referencePaths.length; i++) {
        var refPath = binding.referencePaths[i];
        var innerBinding = refPath.scope.getBinding(path.node.name);
        if (!innerBinding) {
            continue;
        }
        if (!t.isVariableDeclarator(innerBinding.path.node) || !innerBinding.constant) {
            return true;
        }
    }
    return false;
};
/**
 * Will traverse a path and its identifiers to find all bindings.
 * If any of those bindings are mutated `true` will be returned.
 *
 * @param path
 */
var isPathReferencingAnyMutatedIdentifiers = function (path) {
    if (path.isIdentifier()) {
        return isIdentifierReferencesMutated(path);
    }
    var mutated = false;
    path.traverse({
        Identifier: function (innerPath) {
            var result = isIdentifierReferencesMutated(path);
            if (result) {
                mutated = true;
                // No need to keep traversing - let's stop!
                innerPath.stop();
            }
        },
    });
    return mutated;
};
exports.isPathReferencingAnyMutatedIdentifiers = isPathReferencingAnyMutatedIdentifiers;
/**
 * Will try to statically evaluate the node.
 * If successful it will return a literal node,
 * else it will return the fallback node.
 *
 * @param node Node to evaluate
 * @param meta
 * @param fallbackNode Optional node to return if evaluation is not successful. Defaults to `node`.
 */
var tryEvaluateExpression = function (node, meta, fallbackNode) {
    if (fallbackNode === void 0) { fallbackNode = node; }
    if (!node) {
        return node;
    }
    var path = exports.getPathOfNode(node, meta.parentPath);
    if (exports.isPathReferencingAnyMutatedIdentifiers(path)) {
        return fallbackNode;
    }
    var result = path.evaluate();
    if (result.value) {
        switch (typeof result.value) {
            case 'string':
                return t.stringLiteral(result.value);
            case 'number':
                return t.numericLiteral(result.value);
        }
    }
    return fallbackNode;
};
exports.tryEvaluateExpression = tryEvaluateExpression;
var findDefaultExportModuleNode = function (ast) {
    var foundNode = undefined;
    var foundParentPath = undefined;
    traverse_1.default(ast, {
        ExportDefaultDeclaration: function (path) {
            foundParentPath = path;
            foundNode = path.node.declaration;
        },
    });
    return {
        foundNode: foundNode,
        foundParentPath: foundParentPath,
    };
};
var findNamedExportModuleNode = function (ast, exportName) {
    var foundNode = undefined;
    var foundParentPath = undefined;
    traverse_1.default(ast, {
        ExportNamedDeclaration: function (path) {
            if (!path.node.declaration || !t.isVariableDeclaration(path.node.declaration)) {
                return;
            }
            for (var i = 0; i < path.node.declaration.declarations.length; i++) {
                var named = path.node.declaration.declarations[i];
                if (t.isIdentifier(named.id) && named.id.name === exportName) {
                    foundNode = named.init;
                    foundParentPath = path;
                    path.stop();
                    break;
                }
            }
        },
    });
    return {
        foundNode: foundNode,
        foundParentPath: foundParentPath,
    };
};
/**
 * Will recursively checks if identifier name is coming from destructuring. If yes,
 * then will return the resolved identifer. We can look for identifier name
 * either in destructuring key or its value.
 *
 * @param name Identifier name to resolve
 * @param node Any Expression node
 * @param resolveFor Either resolve destructuring key or its value
 */
var resolveIdentifierComingFromDestructuring = function (_a) {
    var name = _a.name, node = _a.node, _b = _a.resolveFor, resolveFor = _b === void 0 ? 'key' : _b;
    var resolvedDestructuringIdentifier;
    if (t.isObjectPattern(node)) {
        var pattern = node;
        return pattern.properties.find(function (property) {
            if (t.isObjectProperty(property)) {
                if (resolveFor === 'key') {
                    return t.isIdentifier(property.key) && property.key.name === name;
                }
                else if (resolveFor === 'value') {
                    return t.isIdentifier(property.value) && property.value.name === name;
                }
            }
            return false;
        });
    }
    else if (t.isVariableDeclarator(node)) {
        var declarator = node;
        resolvedDestructuringIdentifier = exports.resolveIdentifierComingFromDestructuring({
            name: name,
            node: declarator.id,
            resolveFor: resolveFor,
        });
    }
    return resolvedDestructuringIdentifier;
};
exports.resolveIdentifierComingFromDestructuring = resolveIdentifierComingFromDestructuring;
/**
 * Will resolve the value `node` for identifier present inside destructuring
 * If value `node` resolves to an identifier, it will recursively search for its
 * value `node`.
 *
 * For eg.
 * 1. If there is an identifier `foo`, coming from destructuring `{ bar: foo }`
 * having value node as `{ bar: 10 }`, it will resolve to `NumericalLiteral` node `10`.
 * 2. If there is an identifier `foo`, coming from destructuring `{ baz: foo }`
 * referencing an identifier `bar` which in turn having value node as `{ baz: 10 }`,
 * it will search recursively and resolve to `NumericalLiteral` node `10`.
 *
 * @param expression Node inside which we have to resolve the value
 * @param meta Plugin metadata
 * @param referenceName Reference name for which `binding` to be resolved
 */
var resolveObjectPatternValueNode = function (expression, meta, referenceName) {
    var objectPatternValueNode = undefined;
    if (t.isObjectExpression(expression)) {
        traverse_1.default(expression, {
            noScope: true,
            ObjectProperty: {
                exit: function (path) {
                    if (t.isIdentifier(path.node.key, { name: referenceName })) {
                        objectPatternValueNode = path.node.value;
                        path.stop();
                    }
                },
            },
        });
    }
    else if (t.isIdentifier(expression)) {
        var resolvedBinding = exports.resolveBindingNode(expression.name, meta);
        if (resolvedBinding) {
            var isResolvedToSameNode = resolvedBinding.path.node === expression;
            if (!isResolvedToSameNode &&
                resolvedBinding.constant &&
                t.isExpression(resolvedBinding.node)) {
                objectPatternValueNode = resolveObjectPatternValueNode(resolvedBinding.node, meta, referenceName);
            }
        }
    }
    return objectPatternValueNode;
};
/**
 * Will return the `node` of the a binding.
 * This function will follow import specifiers to return the actual `node`.
 *
 * When wanting to do futher traversal on the resulting `node` make sure to use the output `meta` as well.
 * The `meta` will be for the resulting file it was found in.
 *
 * @param referenceName Reference name for which `binding` to be resolved
 * @param meta Plugin metadata
 */
var resolveBindingNode = function (referenceName, meta) {
    var _a, _b;
    var binding = meta.parentPath.scope.getBinding(referenceName);
    if (!binding || binding.path.isObjectPattern()) {
        // Bail early if there is no binding or its a node that we don't want to resolve
        // such as an destructured args from a function.
        return undefined;
    }
    if (t.isVariableDeclarator(binding.path.node)) {
        var node = binding.path.node.init;
        if (t.isObjectPattern(binding.path.node.id) && t.isExpression(node)) {
            node = resolveObjectPatternValueNode(node, meta, referenceName);
        }
        return {
            meta: meta,
            node: node,
            path: binding.path,
            constant: binding.constant,
            source: 'module',
        };
    }
    if (binding.path.parentPath.isImportDeclaration()) {
        // NOTE: We're skipping traversal when file name is not resolved. Imported identifier
        // will end up as a dynamic variable instead.
        if (!meta.state.filename) {
            return;
        }
        var moduleImportName = binding.path.parentPath.node.source.value;
        var isRelative = moduleImportName.charAt(0) === '.';
        var filename = isRelative
            ? path_1.default.join(path_1.default.dirname(meta.state.filename), moduleImportName)
            : moduleImportName;
        var modulePath_1 = resolve_1.default.sync(filename, {
            extensions: ['.js', '.jsx', '.ts', '.tsx'],
        });
        var moduleCode_1 = meta.state.cache.load({
            namespace: 'read-file',
            cacheKey: modulePath_1,
            value: function () { return fs_1.default.readFileSync(modulePath_1, 'utf-8'); },
        });
        var ast_1 = meta.state.cache.load({
            namespace: 'parse-module',
            cacheKey: modulePath_1,
            value: function () { return parser_1.parse(moduleCode_1, { sourceType: 'module', sourceFilename: modulePath_1 }); },
        });
        var foundNode = undefined;
        var foundParentPath = undefined;
        if (binding.path.isImportDefaultSpecifier()) {
            (_a = meta.state.cache.load({
                namespace: 'find-default-export-module-node',
                cacheKey: modulePath_1,
                value: function () { return findDefaultExportModuleNode(ast_1); },
            }), foundNode = _a.foundNode, foundParentPath = _a.foundParentPath);
        }
        else if (binding.path.isImportSpecifier()) {
            var exportName_1 = binding.path.node.local.name;
            (_b = meta.state.cache.load({
                namespace: 'find-named-export-module-node',
                cacheKey: "modulePath=" + modulePath_1 + "&exportName=" + exportName_1,
                value: function () { return findNamedExportModuleNode(ast_1, exportName_1); },
            }), foundNode = _b.foundNode, foundParentPath = _b.foundParentPath);
        }
        if (!foundNode || !foundParentPath) {
            return undefined;
        }
        return {
            constant: binding.constant,
            node: foundNode,
            path: foundParentPath,
            source: 'import',
            meta: __assign(__assign({}, meta), { parentPath: foundParentPath, state: __assign(__assign({}, meta.state), { file: ast_1, filename: filename }) }),
        };
    }
    return {
        node: binding.path.node,
        path: binding.path,
        constant: binding.constant,
        source: 'module',
        meta: meta,
    };
};
exports.resolveBindingNode = resolveBindingNode;
/**
 * Will wrap BlockStatement or Expression in an IIFE,
 * Looks like (() => { return 10; })().
 *
 * @param node Node of type either BlockStatement or Expression
 */
var wrapNodeInIIFE = function (node) {
    return t.callExpression(t.arrowFunctionExpression([], node), []);
};
exports.wrapNodeInIIFE = wrapNodeInIIFE;
var tryWrappingBlockStatementInIIFE = function (node) {
    return t.isBlockStatement(node) ? exports.wrapNodeInIIFE(node) : node;
};
/**
 * Will pick `Function` body and tries to wrap it in an IIFE if
 * its a BlockStatement otherwise returns the picked body,
 * E.g.
 * `props => props.color` would end up as `props.color`.
 * `props => { return props.color; }` would end up as `(() => { return props.color })()`
 * `function () { return props.color; }` would end up as `(function () { return props.color })()`
 *
 * @param node Node of type ArrowFunctionExpression
 */
var pickFunctionBody = function (node) { return tryWrappingBlockStatementInIIFE(node.body); };
exports.pickFunctionBody = pickFunctionBody;
//# sourceMappingURL=ast.js.map