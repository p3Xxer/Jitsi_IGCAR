import * as t from '@babel/types';
import { Tag } from '../types';
import { Metadata } from '../types';
import { CSSOutput } from '../utils/types';
export interface StyledTemplateOpts {
    /**
     * Class to be used for the CSS selector.
     */
    classNames: string[];
    /**
     * Tag for the Styled Component, for example "div" or user defined component.
     */
    tag: Tag;
    /**
     * CSS variables to be passed to the `style` prop.
     */
    variables: CSSOutput['variables'];
    /**
     * CSS sheets to be passed to the `CS` component.
     */
    sheets: string[];
}
/**
 * Will build up the CSS variables prop to be placed as inline styles.
 *
 * @param variables CSS variables that will be placed in the AST
 * @param transform Transform function that can be used to change the CSS variable expression
 */
export declare const buildCssVariablesProp: (variables: CSSOutput['variables'], transform?: (expression: t.Expression) => t.Expression) => (t.ObjectProperty | t.SpreadElement)[];
/**
 * Will return a generated AST for a Compiled Component.
 * This is primarily used for CSS prop and ClassNames apis.
 *
 * @param node Originating node
 * @param sheets Stylesheets
 * @param meta Metadata
 */
export declare const compiledTemplate: (node: t.Expression, sheets: string[], meta: Metadata) => t.Node;
/**
 * Will join two expressions together,
 * Looks like `left + ' ' + right`.
 *
 * @param left Any node on the left
 * @param right Any node on the right
 * @param spacer Optional spacer node to place between the left and right node. Defaults to a space string.
 */
export declare const joinExpressions: (left: any, right: any, spacer?: any) => t.BinaryExpression;
/**
 * Will conditionally join two expressions together depending on the right expression.
 * Looks like: `left + right ? ' ' + right : ''`
 */
export declare const conditionallyJoinExpressions: (left: any, right: any) => t.BinaryExpression;
/**
 * Returns a Styled Component AST.
 *
 * @param tag Styled tag either an inbuilt or user define
 * @param cssOutput CSS and variables to place onto the component
 * @param meta Plugin metadata
 */
export declare const buildStyledComponent: (tag: Tag, cssOutput: CSSOutput, meta: Metadata) => t.Node;
/**
 * Wrapper to make defining import specifiers easier.
 * If `localName` is defined it will rename the import to it,
 * e.g: `name as localName`.
 *
 * @param name import name
 * @param localName local name
 */
export declare const importSpecifier: (name: string, localName?: string | undefined) => t.ImportSpecifier;
/**
 * Returns the actual value of a jsx value.
 *
 * @param node
 */
export declare const getPropValue: (node: t.JSXElement | t.JSXFragment | t.StringLiteral | t.JSXExpressionContainer) => t.Expression;
/**
 * Returns a Compiled Component AST.
 *
 * @param node Originating node
 * @param cssOutput CSS and variables to place onto the component
 * @param meta Plugin metadata
 */
export declare const buildCompiledComponent: (node: t.JSXElement, cssOutput: CSSOutput, meta: Metadata) => t.Node;
