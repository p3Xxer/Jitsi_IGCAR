"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildCss = exports.getItemCss = void 0;
var t = __importStar(require("@babel/types"));
var generator_1 = __importDefault(require("@babel/generator"));
var css_1 = require("@compiled/css");
var utils_1 = require("@compiled/utils");
var ast_1 = require("./ast");
var evaluate_expression_1 = require("./evaluate-expression");
/**
 * Will normalize the value of a `content` CSS property to ensure it has quotations around it.
 * This is done to replicate both how Styled Components behaves,
 * while not breaking how Emotion handles it.
 */
var normalizeContentValue = function (value) {
    if (value.charAt(0) !== '"' && value.charAt(0) !== "'") {
        return "\"" + value + "\"";
    }
    return value;
};
/**
 * Will merge all subsequent unconditional CSS expressions together.
 *
 * Input
 *
 * ```
 * [l, u, u, l, u, u, u, u, l, u]
 * ```
 *
 * Output
 *
 * ```
 * [l, uu, l, uuuu, l, u]
 * ```
 *
 * Where `l` is a logical item,
 * and `u` is a unconditional item.
 *
 * @param arr
 */
var mergeSubsequentUnconditionalCssItems = function (arr) {
    var items = [];
    for (var index = 0; index < arr.length; index++) {
        var item = arr[index];
        if (item.type === 'unconditional') {
            // We found an unconditional. Let's iterate further and merge all subsequent ones.
            for (var subsequentIndex = index + 1; subsequentIndex < arr.length; subsequentIndex++) {
                var subsequentItem = arr[subsequentIndex];
                if (subsequentItem.type === 'unconditional') {
                    item.css += subsequentItem.css;
                }
                else {
                    break;
                }
                // Update index back to the new one which we'll start from again.
                index = subsequentIndex;
            }
        }
        items.push(item);
    }
    return items;
};
/**
 * Returns the item css.
 *
 * @param item
 */
var getItemCss = function (item) {
    return item.css;
};
exports.getItemCss = getItemCss;
/**
 * Parses a CSS output to amn array of CSS item rules.
 *
 * @param selector
 * @param result
 */
var toCSSRule = function (selector, result) {
    return result.css.map(function (x) { return (__assign(__assign({}, x), { css: selector + " { " + exports.getItemCss(x) + " }" })); });
};
/**
 * Parses a CSS output to an array of CSS item declarations.
 *
 * @param key
 * @param result
 */
var toCSSDeclaration = function (key, result) {
    return result.css.map(function (x) { return (__assign(__assign({}, x), { css: utils_1.kebabCase(key) + ": " + exports.getItemCss(x) + ";" })); });
};
/**
 * Extracts CSS data from an object expression node.
 *
 * @param node Node we're interested in extracting CSS from.
 * @param state Babel state - should house options and meta data used during the transformation.
 */
var extractObjectExpression = function (node, meta) {
    var variables = [];
    var css = [];
    node.properties.forEach(function (prop) {
        if (t.isObjectProperty(prop)) {
            // Don't use prop.value directly as it extracts constants from identifiers if needed.
            var _a = evaluate_expression_1.evaluateExpression(prop.value, meta), propValue = _a.value, updatedMeta = _a.meta;
            var key = ast_1.getKey(prop.key);
            var value = '';
            if (t.isStringLiteral(propValue)) {
                // We've found a string literal like: `color: 'blue'`
                value = key === 'content' ? normalizeContentValue(propValue.value) : propValue.value;
            }
            else if (t.isNumericLiteral(propValue)) {
                // We've found a numeric literal like: `fontSize: 12`
                value = css_1.addUnitIfNeeded(key, propValue.value);
            }
            else if (t.isObjectExpression(propValue) || t.isLogicalExpression(propValue)) {
                // We've found either an object like `{}` or a logical expression `isPrimary && {}`.
                // We can handle both the same way as they end up resulting in a CSS rule.
                var result = exports.buildCss(propValue, updatedMeta);
                css.push.apply(css, toCSSRule(key, result));
                variables.push.apply(variables, result.variables);
                return;
            }
            else if (t.isTemplateLiteral(propValue)) {
                // We've found a template literal like: `fontSize: `${fontSize}px`
                var result = extractTemplateLiteral(propValue, updatedMeta);
                css.push.apply(css, toCSSDeclaration(key, result));
                variables.push.apply(variables, result.variables);
                return;
            }
            else {
                // This is the catch all for any kind of expression.
                // We don't want to explicitly handle each expression node differently if we can avoid it!
                var variableName = "--_" + utils_1.hash(generator_1.default(propValue).code);
                variables.push({ name: variableName, expression: propValue });
                value = "var(" + variableName + ")";
            }
            // Time to add this key+value to the CSS string we're building up.
            css.push({ type: 'unconditional', css: utils_1.kebabCase(key) + ": " + value + ";" });
        }
        else if (t.isSpreadElement(prop)) {
            var resolvedBinding = undefined;
            if (t.isIdentifier(prop.argument)) {
                resolvedBinding = ast_1.resolveBindingNode(prop.argument.name, meta);
                if (!resolvedBinding) {
                    throw ast_1.buildCodeFrameError('Variable could not be found', prop.argument, meta.parentPath);
                }
            }
            var _b = evaluate_expression_1.evaluateExpression(prop.argument, meta), propValue = _b.value, updatedMeta = _b.meta;
            var result = exports.buildCss(propValue, updatedMeta);
            if ((resolvedBinding === null || resolvedBinding === void 0 ? void 0 : resolvedBinding.source) === 'import' && result.variables.length > 0) {
                // NOTE: Currently we throw if the found CSS has any variables found from an
                // import. This is because we'd need to ensure all identifiers are added to
                // the owning file - if not done they would just error at runtime. Because
                // this isn't a required feature at the moment we're deprioritizing support
                // for this.
                throw ast_1.buildCodeFrameError("Identifier contains values that can't be statically evaluated", prop.argument, meta.parentPath);
            }
            css.push.apply(css, result.css);
            variables.push.apply(variables, result.variables);
        }
    });
    return { css: mergeSubsequentUnconditionalCssItems(css), variables: variables };
};
/**
 * Extracts CSS data from a template literal node.
 *
 * @param node Node we're interested in extracting CSS from.
 * @param state Babel state - should house options and meta data used during the transformation.
 */
var extractTemplateLiteral = function (node, meta) {
    var variables = [];
    var css = [];
    // quasis are the string pieces of the template literal - the parts around the interpolations.
    var literalResult = node.quasis.reduce(function (acc, q, index) {
        var nodeExpression = node.expressions[index];
        var _a = evaluate_expression_1.evaluateExpression(nodeExpression, meta), interpolation = _a.value, updatedMeta = _a.meta;
        if (t.isStringLiteral(interpolation) || t.isNumericLiteral(interpolation)) {
            // Simple case - we can immediately inline the value.
            return acc + q.value.raw + interpolation.value;
        }
        if (t.isObjectExpression(interpolation)) {
            // We found an object like: css`${{ red: 'blue' }}`.
            var result = exports.buildCss(interpolation, updatedMeta);
            variables.push.apply(variables, result.variables);
            css.push.apply(css, result.css);
            return acc;
        }
        if (interpolation) {
            // Everything else is considered a catch all expression.
            // The only difficulty here is what we do around prefixes and suffixes.
            // CSS variables can't have them! So we need to move them to the inline style.
            // E.g. `font-size: ${fontSize}px` will end up needing to look like:
            // `font-size: var(--_font-size)`, with the suffix moved to inline styles
            // style={{ '--_font-size': fontSize + 'px' }}
            var variableName = "--_" + utils_1.hash(generator_1.default(interpolation).code);
            var nextQuasis = node.quasis[index + 1];
            var before = css_1.cssBeforeInterpolation(css + q.value.raw);
            var after = css_1.cssAfterInterpolation(nextQuasis.value.raw);
            nextQuasis.value.raw = after.css; // Removes any suffixes from the next quasis.
            variables.push({
                name: variableName,
                expression: interpolation,
                prefix: before.variablePrefix,
                suffix: after.variableSuffix,
            });
            return acc + before.css + ("var(" + variableName + ")");
        }
        return acc + q.value.raw + ';';
    }, '');
    css.push({ type: 'unconditional', css: literalResult });
    return { css: mergeSubsequentUnconditionalCssItems(css), variables: variables };
};
/**
 * Will return a CSS string and CSS variables array from an input node.
 *
 * @param node Node we're interested in extracting CSS from.
 * @param state Babel state - should house options and meta data used during the transformation.
 */
var buildCss = function (node, meta) {
    if (t.isStringLiteral(node)) {
        return { css: [{ type: 'unconditional', css: node.value }], variables: [] };
    }
    if (t.isTemplateLiteral(node)) {
        return extractTemplateLiteral(node, meta);
    }
    if (t.isObjectExpression(node)) {
        return extractObjectExpression(node, meta);
    }
    if (t.isIdentifier(node)) {
        var resolvedBinding = ast_1.resolveBindingNode(node.name, meta);
        if (!resolvedBinding) {
            throw ast_1.buildCodeFrameError('Variable could not be found', node, meta.parentPath);
        }
        if (!t.isExpression(resolvedBinding.node)) {
            throw ast_1.buildCodeFrameError(resolvedBinding.node.type + " isn't a supported CSS type - try using an object or string", node, meta.parentPath);
        }
        var result = exports.buildCss(resolvedBinding.node, resolvedBinding.meta);
        if (resolvedBinding.source === 'import' && result.variables.length > 0) {
            // NOTE: Currently we throw if the found CSS has any variables found from an
            // import. This is because we'd need to ensure all identifiers are added to
            // the owning file - if not done they would just error at runtime. Because
            // this isn't a required feature at the moment we're deprioritizing support
            // for this.
            throw ast_1.buildCodeFrameError("Identifier contains values that can't be statically evaluated", node, meta.parentPath);
        }
        return result;
    }
    if (t.isArrayExpression(node) || Array.isArray(node)) {
        var css_2 = [];
        var variables_1 = [];
        var elements = t.isArrayExpression(node) ? node.elements : node;
        elements.forEach(function (element) {
            if (!t.isExpression(element)) {
                throw ast_1.buildCodeFrameError((element && element.type) + " isn't a supported CSS type - try using an object or string", t.isArrayExpression(node) ? node : element, meta.parentPath);
            }
            var result = exports.buildCss(element, meta);
            css_2.push.apply(css_2, result.css);
            variables_1.push.apply(variables_1, result.variables);
        });
        return {
            css: css_2,
            variables: variables_1,
        };
    }
    if (t.isLogicalExpression(node)) {
        var expression_1 = node.left;
        var result = exports.buildCss(node.right, meta);
        var css = result.css.map(function (item) {
            if (item.type !== 'unconditional') {
                return __assign(__assign({}, item), { expression: t.logicalExpression(item.operator, expression_1, item.expression) });
            }
            var logicalItem = {
                type: 'logical',
                css: item.css,
                expression: expression_1,
                operator: node.operator,
            };
            return logicalItem;
        });
        return {
            css: css,
            variables: result.variables,
        };
    }
    throw ast_1.buildCodeFrameError(node.type + " isn't a supported CSS type - try using an object or string", node, meta.parentPath);
};
exports.buildCss = buildCss;
//# sourceMappingURL=css-builders.js.map