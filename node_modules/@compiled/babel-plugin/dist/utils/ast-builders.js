"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildCompiledComponent = exports.getPropValue = exports.importSpecifier = exports.buildStyledComponent = exports.conditionallyJoinExpressions = exports.joinExpressions = exports.compiledTemplate = exports.buildCssVariablesProp = void 0;
var template_1 = __importDefault(require("@babel/template"));
var t = __importStar(require("@babel/types"));
var traverse_1 = __importDefault(require("@babel/traverse"));
var utils_1 = require("@compiled/utils");
var css_1 = require("@compiled/css");
var is_prop_valid_1 = __importDefault(require("@emotion/is-prop-valid"));
var css_builders_1 = require("./css-builders");
var ast_1 = require("./ast");
var constants_1 = require("../constants");
/**
 * Hoists a sheet to the top of the module if its not already there.
 * Returns the referencing identifier.
 *
 * @param sheet Stylesheet
 * @param meta Plugin metadata
 */
var hoistSheet = function (sheet, meta) {
    if (meta.state.sheets[sheet]) {
        return meta.state.sheets[sheet];
    }
    var sheetIdentifier = meta.parentPath.scope.generateUidIdentifier('');
    var parent = meta.parentPath.findParent(function (path) { return path.isProgram(); });
    var parentBody = parent && parent.get('body');
    var path = parentBody && parentBody.filter(function (path) { return !path.isImportDeclaration(); })[0];
    path &&
        path.insertBefore(t.variableDeclaration('const', [
            t.variableDeclarator(sheetIdentifier, t.stringLiteral(sheet)),
        ]));
    meta.state.sheets[sheet] = sheetIdentifier;
    return sheetIdentifier;
};
/**
 * Will build up the CSS variables prop to be placed as inline styles.
 *
 * @param variables CSS variables that will be placed in the AST
 * @param transform Transform function that can be used to change the CSS variable expression
 */
var buildCssVariablesProp = function (variables, transform) {
    if (transform === void 0) { transform = function (expression) { return expression; }; }
    return utils_1.unique(
    // Make sure all defined CSS variables are unique
    variables, 
    // We consider their uniqueness based on their name
    function (item) { return item.name; }).map(function (variable) {
        // Map them into object properties.
        return t.objectProperty(t.stringLiteral(variable.name), t.callExpression(t.identifier('ix'), [
            // Allow callers to transform the expression if needed,
            // for example the styled API strips away the arrow function.
            transform(variable.expression),
            (variable.suffix && t.stringLiteral(variable.suffix)),
            (variable.suffix && variable.prefix && t.stringLiteral(variable.prefix)),
        ].filter(Boolean)));
    });
};
exports.buildCssVariablesProp = buildCssVariablesProp;
/**
 * Builds up the inline style prop value for a Styled Component.
 *
 * @param variables CSS variables that will be placed in the AST
 * @param transform Transform callback function that can be used to change the CSS variable expression
 */
var styledStyleProp = function (variables, transform) {
    var props = [t.spreadElement(t.identifier('style'))];
    return t.objectExpression(props.concat(exports.buildCssVariablesProp(variables, transform)));
};
/**
 * Returns a tag string in the form of an identifier or string literal.
 *
 * A type of InBuiltComponent will return a string literal,
 * otherwise an identifier string will be returned.
 *
 * @param tag Made of name and type.
 */
var buildComponentTag = function (_a) {
    var name = _a.name, type = _a.type;
    return type === 'InBuiltComponent' ? "\"" + name + "\"" : name;
};
/**
 * Traverses an arrow function and then finally return the arrow function body node.
 *
 * @param node Array function node
 * @param nestedVisitor Visitor callback function
 */
var traverseStyledArrowFunctionExpression = function (node, nestedVisitor) {
    traverse_1.default(node, nestedVisitor);
    return ast_1.pickFunctionBody(node);
};
/**
 * Traverses a binary expression looking for any arrow functions,
 * calls back with each arrow function node into the passed in `nestedVisitor`,
 * and then finally replaces each found arrow function node with its body.
 *
 * @param node Binary expression node
 * @param nestedVisitor Visitor callback function
 */
var traverseStyledBinaryExpression = function (node, nestedVisitor) {
    traverse_1.default(node, {
        noScope: true,
        ArrowFunctionExpression: function (path) {
            path.traverse(nestedVisitor);
            path.replaceWith(ast_1.pickFunctionBody(path.node));
            path.stop();
        },
    });
    return node;
};
/**
 * Handles cases like:
 * 1. `propz.loading` in `border-color: \${(propz) => (propz.loading ? colors.N100 : colors.N200)};`
 * Outcome: It will replace `propz.loading` with `props.loading`.
 *
 * 2. `props.notValidProp` in `border-color: \${(props) => (props.notValidProp ? colors.N100 : colors.N200)};`
 * Outcome: It will move `notValidProp` under `propsToDestructure` and replaces `props.notValidProp` with `notValidProp`.
 *
 * @param path MemberExpression path
 */
var handleMemberExpressionInStyledInterpolation = function (path) {
    var memberExpressionKey = path.node.object;
    var propsToDestructure = [];
    if (t.isIdentifier(memberExpressionKey)) {
        var traversedUpFunctionPath = path.find(function (parentPath) {
            return parentPath.isFunction();
        });
        var memberExpressionKeyName = memberExpressionKey.name;
        var isMemberExpressionNameTheSameAsFunctionFirstParam = traversedUpFunctionPath &&
            t.isFunction(traversedUpFunctionPath.node) &&
            t.isIdentifier(traversedUpFunctionPath.node.params[0]) &&
            traversedUpFunctionPath.node.params[0].name === memberExpressionKeyName;
        if (isMemberExpressionNameTheSameAsFunctionFirstParam) {
            var memberExpressionValue = path.node.property;
            if (t.isIdentifier(memberExpressionValue)) {
                var memberExpressionValueName = memberExpressionValue.name;
                // if valid html attribute let it through - else destructure to prevent
                if (is_prop_valid_1.default(memberExpressionValueName)) {
                    // Convert cases like propz.color to props.color
                    if (memberExpressionKeyName !== constants_1.PROPS_IDENTIFIER_NAME) {
                        path.replaceWith(t.memberExpression(t.identifier(constants_1.PROPS_IDENTIFIER_NAME), t.identifier(memberExpressionValueName)));
                    }
                }
                else {
                    propsToDestructure.push(memberExpressionValueName);
                    path.replaceWith(memberExpressionValue);
                }
            }
        }
    }
    return propsToDestructure;
};
/**
 * Handles cases like:
 * 1. `isLoading` in `background-color: \${({ isLoading }) => (isLoading ? colors.N20 : colors.N40)};`
 * Outcome: It will move `isLoading` under `propsToDestructure`.
 *
 * 2. `l` in `color: \${({ loading: l }) => (l ? colors.N50 : colors.N10)};`
 * Outcome: It will move `loading` under `propsToDestructure` and replaces `l` with `loading`.
 *
 * @param path Identifier path
 */
var handleDestructuringInStyledInterpolation = function (path) {
    var propsToDestructure = [];
    // We are not interested in parent object property like `({ loading: load }) => load`.
    // Both `: load` and `=> load` are identifiers and function is parent for both.
    // We are not interested in modifying `: load`. We just need to modify `=> load` to `=> loading`.
    // If we don't skip, `=> load` will not be modified because we have modified `: load` earlier and
    // second identifier is nowhere to be found inside function params.
    if (path.parentPath && !t.isObjectProperty(path.parentPath.node)) {
        var traversedUpFunctionPath = path.find(function (parentPath) {
            return parentPath.isFunction();
        });
        var firstFunctionParam = traversedUpFunctionPath &&
            t.isFunction(traversedUpFunctionPath.node) &&
            traversedUpFunctionPath.node.params[0];
        var resolvedDestructuringIdentifier = ast_1.resolveIdentifierComingFromDestructuring({
            name: path.node.name,
            node: firstFunctionParam,
            resolveFor: 'value',
        });
        if (resolvedDestructuringIdentifier && t.isIdentifier(resolvedDestructuringIdentifier.key)) {
            var resolvedDestructuringIdentifierKey = resolvedDestructuringIdentifier.key;
            var resolvedDestructuringIdentifierKeyName = resolvedDestructuringIdentifierKey.name;
            propsToDestructure.push(resolvedDestructuringIdentifierKeyName);
            // We are only interested in cases when names are different otherwise this will go in infinite recursion.
            if (resolvedDestructuringIdentifierKeyName !== path.node.name) {
                path.replaceWith(t.identifier(resolvedDestructuringIdentifierKeyName));
            }
        }
    }
    return propsToDestructure;
};
/**
 * Will return a generated AST for a Styled Component.
 *
 * @param opts Template options
 * @param meta Plugin metadata
 */
var styledTemplate = function (opts, meta) {
    var nonceAttribute = meta.state.opts.nonce ? "nonce={" + meta.state.opts.nonce + "}" : '';
    var propsToDestructure = [];
    var styleProp = opts.variables.length
        ? styledStyleProp(opts.variables, function (node) {
            var nestedArrowFunctionExpressionVisitor = {
                noScope: true,
                MemberExpression: function (path) {
                    var propsToDestructureFromMemberExpression = handleMemberExpressionInStyledInterpolation(path);
                    propsToDestructure.push.apply(propsToDestructure, propsToDestructureFromMemberExpression);
                },
                Identifier: function (path) {
                    var propsToDestructureFromIdentifier = handleDestructuringInStyledInterpolation(path);
                    propsToDestructure.push.apply(propsToDestructure, propsToDestructureFromIdentifier);
                },
            };
            if (t.isArrowFunctionExpression(node)) {
                return traverseStyledArrowFunctionExpression(node, nestedArrowFunctionExpressionVisitor);
            }
            if (t.isBinaryExpression(node)) {
                return traverseStyledBinaryExpression(node, nestedArrowFunctionExpressionVisitor);
            }
            return node;
        })
        : t.identifier('style');
    return template_1.default("\n  forwardRef(({\n    as: C = " + buildComponentTag(opts.tag) + ",\n    style,\n    " + utils_1.unique(propsToDestructure)
        .map(function (prop) { return prop + ','; })
        .join('') + "\n    ..." + constants_1.PROPS_IDENTIFIER_NAME + "\n  }, ref) => (\n    <CC>\n      <CS " + nonceAttribute + ">{%%cssNode%%}</CS>\n      <C\n        {..." + constants_1.PROPS_IDENTIFIER_NAME + "}\n        style={%%styleProp%%}\n        ref={ref}\n        className={ax([\"" + opts.classNames.join(' ') + "\", " + constants_1.PROPS_IDENTIFIER_NAME + ".className])}\n      />\n    </CC>\n  ));\n", {
        plugins: ['jsx'],
    })({
        styleProp: styleProp,
        cssNode: t.arrayExpression(utils_1.unique(opts.sheets).map(function (sheet) { return hoistSheet(sheet, meta); })),
    });
};
/**
 * Will return a generated AST for a Compiled Component.
 * This is primarily used for CSS prop and ClassNames apis.
 *
 * @param node Originating node
 * @param sheets Stylesheets
 * @param meta Metadata
 */
var compiledTemplate = function (node, sheets, meta) {
    var nonceAttribute = meta.state.opts.nonce ? "nonce={" + meta.state.opts.nonce + "}" : '';
    return template_1.default("\n  <CC>\n    <CS " + nonceAttribute + ">{%%cssNode%%}</CS>\n    {%%jsxNode%%}\n  </CC>\n  ", {
        plugins: ['jsx'],
    })({
        jsxNode: node,
        cssNode: t.arrayExpression(utils_1.unique(sheets).map(function (sheet) { return hoistSheet(sheet, meta); })),
    });
};
exports.compiledTemplate = compiledTemplate;
/**
 * Will join two expressions together,
 * Looks like `left + ' ' + right`.
 *
 * @param left Any node on the left
 * @param right Any node on the right
 * @param spacer Optional spacer node to place between the left and right node. Defaults to a space string.
 */
var joinExpressions = function (left, right, spacer) {
    if (spacer === void 0) { spacer = t.stringLiteral(' '); }
    return t.binaryExpression('+', left, spacer ? t.binaryExpression('+', spacer, right) : right);
};
exports.joinExpressions = joinExpressions;
/**
 * Will conditionally join two expressions together depending on the right expression.
 * Looks like: `left + right ? ' ' + right : ''`
 */
var conditionallyJoinExpressions = function (left, right) {
    return t.binaryExpression('+', left, t.conditionalExpression(right, t.binaryExpression('+', t.stringLiteral(' '), right), t.stringLiteral('')));
};
exports.conditionallyJoinExpressions = conditionallyJoinExpressions;
/**
 * Returns a Styled Component AST.
 *
 * @param tag Styled tag either an inbuilt or user define
 * @param cssOutput CSS and variables to place onto the component
 * @param meta Plugin metadata
 */
var buildStyledComponent = function (tag, cssOutput, meta) {
    var _a = css_1.transformCss(cssOutput.css.map(function (x) { return css_builders_1.getItemCss(x); }).join('')), sheets = _a.sheets, classNames = _a.classNames;
    return styledTemplate({
        classNames: classNames,
        tag: tag,
        sheets: sheets,
        variables: cssOutput.variables,
    }, meta);
};
exports.buildStyledComponent = buildStyledComponent;
/**
 * Wrapper to make defining import specifiers easier.
 * If `localName` is defined it will rename the import to it,
 * e.g: `name as localName`.
 *
 * @param name import name
 * @param localName local name
 */
var importSpecifier = function (name, localName) {
    return t.importSpecifier(t.identifier(name), t.identifier(localName || name));
};
exports.importSpecifier = importSpecifier;
/**
 * Returns the actual value of a jsx value.
 *
 * @param node
 */
var getPropValue = function (node) {
    var value = t.isJSXExpressionContainer(node) ? node.expression : node;
    if (t.isJSXEmptyExpression(value)) {
        throw new Error('Empty expression not supported.');
    }
    return value;
};
exports.getPropValue = getPropValue;
/**
 * Transforms CSS output into `sheets` and `classNames` ASTs.
 *
 * @param cssOutput CSSOutput
 */
var transformItemCss = function (cssOutput) {
    var sheets = [];
    var classNames = [];
    cssOutput.css.forEach(function (item) {
        var css = css_1.transformCss(css_builders_1.getItemCss(item));
        var className = css.classNames.join(' ');
        sheets.push.apply(sheets, css.sheets);
        switch (item.type) {
            case 'logical':
                classNames.push(t.logicalExpression(item.operator, item.expression, t.stringLiteral(className)));
                break;
            case 'unconditional':
            default:
                classNames.push(t.stringLiteral(className));
                break;
        }
    });
    return { sheets: sheets, classNames: classNames };
};
/**
 * Returns a Compiled Component AST.
 *
 * @param node Originating node
 * @param cssOutput CSS and variables to place onto the component
 * @param meta Plugin metadata
 */
var buildCompiledComponent = function (node, cssOutput, meta) {
    var _a = transformItemCss(cssOutput), sheets = _a.sheets, classNames = _a.classNames;
    var classNameProp = node.openingElement.attributes.find(function (prop) {
        return t.isJSXAttribute(prop) && prop.name.name === 'className';
    });
    if (classNameProp && classNameProp.value) {
        // If there is a class name prop statically defined we want to concatenate it with
        // the class name we're going to put on it.
        var classNameExpression = exports.getPropValue(classNameProp.value);
        var values = classNames.concat(classNameExpression);
        classNameProp.value = t.jsxExpressionContainer(t.callExpression(t.identifier('ax'), [t.arrayExpression(values)]));
    }
    else {
        // No class name - just push our own one.
        node.openingElement.attributes.push(t.jsxAttribute(t.jsxIdentifier('className'), t.jsxExpressionContainer(t.callExpression(t.identifier('ax'), [t.arrayExpression(classNames)]))));
    }
    if (cssOutput.variables.length) {
        // If there is dynamic CSS in use we have work to do.
        var stylePropIndex_1 = -1;
        // Find the style prop on the opening JSX element.
        var styleProp = node.openingElement.attributes.find(function (prop, index) {
            if (t.isJSXAttribute(prop) && prop.name.name === 'style') {
                stylePropIndex_1 = index;
                return true;
            }
            return false;
        });
        var dynamicStyleProperties_1 = exports.buildCssVariablesProp(cssOutput.variables);
        if (styleProp) {
            // Remove the pre-existing style prop - we're going to redefine it soon.
            node.openingElement.attributes.splice(stylePropIndex_1, 1);
            if (styleProp.value &&
                t.isJSXExpressionContainer(styleProp.value) &&
                !t.isJSXEmptyExpression(styleProp.value.expression)) {
                // If it's not an object we just spread the expression into the object
                if (!t.isObjectExpression(styleProp.value.expression)) {
                    dynamicStyleProperties_1.splice(0, 0, t.spreadElement(styleProp.value.expression));
                }
                else {
                    // Else it's an object! So we want to place each property into the object
                    styleProp.value.expression.properties.forEach(function (prop, index) {
                        if (t.isObjectMethod(prop)) {
                            return;
                        }
                        // We want to keep the order that they were defined in.
                        // So we're using index here to do just that.
                        dynamicStyleProperties_1.splice(index, 0, prop);
                    });
                }
            }
        }
        // Finally add the new style prop back to the opening JSX element.
        node.openingElement.attributes.push(t.jsxAttribute(t.jsxIdentifier('style'), t.jsxExpressionContainer(t.objectExpression(dynamicStyleProperties_1))));
    }
    return exports.compiledTemplate(node, sheets, meta);
};
exports.buildCompiledComponent = buildCompiledComponent;
//# sourceMappingURL=ast-builders.js.map