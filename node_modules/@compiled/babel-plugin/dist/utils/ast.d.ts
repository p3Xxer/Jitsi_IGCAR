import * as t from '@babel/types';
import { NodePath } from '@babel/traverse';
import { Metadata } from '../types';
/**
 * Returns the nodes path including the scope of a parent.
 * @param node
 * @param parentPath
 */
export declare const getPathOfNode: <TNode extends unknown>(node: TNode, parentPath: NodePath) => NodePath<TNode>;
/**
 * Builds a code frame error from a passed in node.
 *
 * @param error
 * @param node
 * @param parentPath
 */
export declare const buildCodeFrameError: (error: string, node: t.Node | null, parentPath: NodePath<any>) => Error;
/**
 * Returns the binding identifier for a member expression.
 *
 * For example:
 * 1. Member expression `foo.bar.baz` will return the `foo` identifier along
 * with `originalBindingType` as 'Identifier'.
 * 2. Member expression with function call `foo().bar.baz` will return the
 * `foo` identifier along with `originalBindingType` as 'CallExpression'.
 *
 * @param expression - Member expression node.
 */
export declare const getMemberExpressionMeta: (expression: t.MemberExpression) => {
    accessPath: t.Identifier[];
    bindingIdentifier: t.Identifier | null;
    originalBindingType: t.Expression['type'];
};
/**
 * Will return the value of a path from an object expression.
 *
 * For example if  we take an object expression that looks like:
 * ```
 * { colors: { primary: 'red' } }
 * ```
 *
 * And a path of identifiers that looks like:
 * ```
 * [colors, primary]
 * ```
 *
 * Would result in returning the `red` string literal node.
 * If the value is not found `undefined` will be returned.
 *
 * @param expression - Member expression node.
 * @param accessPath - Access path identifiers.
 */
export declare const getValueFromObjectExpression: (expression: t.ObjectExpression, accessPath: t.Identifier[]) => t.Node | undefined;
/**
 * Will return either the name of an identifier or the value of a string literal.
 *
 * E.g:
 * - `foo` identifier node will return `"foo"`,
 * - `"bar"` string literal node will return `"bar"`.
 *
 * @param node
 */
export declare const getKey: (node: t.Expression) => string;
/**
 * Will traverse a path and its identifiers to find all bindings.
 * If any of those bindings are mutated `true` will be returned.
 *
 * @param path
 */
export declare const isPathReferencingAnyMutatedIdentifiers: (path: NodePath<any>) => boolean;
/**
 * Will try to statically evaluate the node.
 * If successful it will return a literal node,
 * else it will return the fallback node.
 *
 * @param node Node to evaluate
 * @param meta
 * @param fallbackNode Optional node to return if evaluation is not successful. Defaults to `node`.
 */
export declare const tryEvaluateExpression: (node: t.Expression, meta: Metadata, fallbackNode?: t.Expression) => t.Expression;
interface PartialBindingWithMeta {
    node: t.Node;
    path: NodePath;
    constant: boolean;
    meta: Metadata;
    source: 'import' | 'module';
}
/**
 * Will recursively checks if identifier name is coming from destructuring. If yes,
 * then will return the resolved identifer. We can look for identifier name
 * either in destructuring key or its value.
 *
 * @param name Identifier name to resolve
 * @param node Any Expression node
 * @param resolveFor Either resolve destructuring key or its value
 */
export declare const resolveIdentifierComingFromDestructuring: ({ name, node, resolveFor, }: {
    name: string;
    node: t.Expression | undefined;
    resolveFor?: "value" | "key" | undefined;
}) => t.ObjectProperty | undefined;
/**
 * Will return the `node` of the a binding.
 * This function will follow import specifiers to return the actual `node`.
 *
 * When wanting to do futher traversal on the resulting `node` make sure to use the output `meta` as well.
 * The `meta` will be for the resulting file it was found in.
 *
 * @param referenceName Reference name for which `binding` to be resolved
 * @param meta Plugin metadata
 */
export declare const resolveBindingNode: (referenceName: string, meta: Metadata) => PartialBindingWithMeta | undefined;
/**
 * Will wrap BlockStatement or Expression in an IIFE,
 * Looks like (() => { return 10; })().
 *
 * @param node Node of type either BlockStatement or Expression
 */
export declare const wrapNodeInIIFE: (node: t.BlockStatement | t.Expression) => t.CallExpression;
/**
 * Will pick `Function` body and tries to wrap it in an IIFE if
 * its a BlockStatement otherwise returns the picked body,
 * E.g.
 * `props => props.color` would end up as `props.color`.
 * `props => { return props.color; }` would end up as `(() => { return props.color })()`
 * `function () { return props.color; }` would end up as `(function () { return props.color })()`
 *
 * @param node Node of type ArrowFunctionExpression
 */
export declare const pickFunctionBody: (node: t.Function) => t.Expression;
export {};
