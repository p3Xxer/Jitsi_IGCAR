import { PluginOptions } from '../types';
export interface CacheOptions extends PluginOptions {
    cache?: boolean;
    maxSize?: number;
}
declare const defaultOptions: {
    cache: boolean;
    maxSize: number;
};
export declare class Cache {
    _options: CacheOptions & typeof defaultOptions;
    _cache: InstanceType<typeof Map>;
    constructor();
    /**
     * Returns hash of `cacheKey` and `namespace` if `namespace` is present
     * otherwise returns hash of `cacheKey` only.
     *
     * @param cacheKey Key for caching
     * @param namespace Namespace for grouping
     */
    static getUniqueKey(cacheKey: string, namespace?: string): string;
    /**
     * Lazy evaluates the passed value and save it into the cache.
     * Also returns the lazy evaluated value.
     *
     * @param uniqueKey Unique cache key
     * @param value Value to be cached
     */
    _saveToCache<T>(uniqueKey: string, value: () => T): T;
    /**
     * Deletes least recently used value (first in queue) from cache if cache size
     * reaches its max size.
     */
    _tryDeletingLRUCachedValue(): void;
    /**
     * Moves frequently accessed value last into queue so that they won't get deleted
     * when cache size reaches its max size.
     *
     * @param uniqueKey Unique cache key
     * @param cacheValue Cached value
     */
    _moveLastInQueue<T>(uniqueKey: string, cacheValue: T): void;
    /**
     * Loads cached value from cache and returns it. Also move it last into queue.
     *
     * @param uniqueKey Unique cache key
     */
    _loadFromCache<T>(uniqueKey: string): T;
    /**
     * Initialize cache with its options.
     *
     * @param options Cache options
     */
    initialize(options: CacheOptions): void;
    /**
     * Checks if we can cache the value. If not, it will just evaluate the passed
     * value and returns it. If yes, it will start caching it. If value is already
     * cached, returns it otherwise put it into the cache and delete least recently
     * used value if cache is full.
     *
     * @param cacheKey Key for caching
     * @param namespace Namespace for grouping
     * @param value Value to be cached
     */
    load<T>({ cacheKey, namespace, value, }: {
        cacheKey: string;
        namespace?: string;
        value?: () => T;
    }): T;
    /**
     * Returns cache size
     */
    getSize(): number;
    /**
     * Returns cache keys
     */
    getKeys(): IterableIterator<unknown>;
    /**
     * Returns cache values
     */
    getValues(): IterableIterator<unknown>;
}
export {};
