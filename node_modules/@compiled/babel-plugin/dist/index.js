"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var helper_plugin_utils_1 = require("@babel/helper-plugin-utils");
var template_1 = __importDefault(require("@babel/template"));
var t = __importStar(require("@babel/types"));
var plugin_syntax_jsx_1 = __importDefault(require("@babel/plugin-syntax-jsx"));
var path = __importStar(require("path"));
var ast_builders_1 = require("./utils/ast-builders");
var cache_1 = require("./utils/cache");
var css_prop_1 = require("./css-prop");
var styled_1 = require("./styled");
var class_names_1 = require("./class-names");
// eslint-disable-next-line @typescript-eslint/no-var-requires
var pkgJson = require('../package.json');
var cache = new cache_1.Cache();
var parseFilename = function (filename) {
    if (!filename) {
        return 'File';
    }
    return path.basename(filename);
};
/**
 * Appends runtime import to code. If it is already present, it will append import specifiers
 * to already imported declaration path else it will create fresh import declaration path
 * with runtime import specifiers.
 *
 * @param path ImportDeclaration node path
 */
var appendRuntimeImports = function (path) {
    var runtimeImportNames = ['ax', 'ix', 'CC', 'CS'];
    var runtimeImportModuleName = '@compiled/react/runtime';
    // Check if we have any sibling runtime import
    var runtimeImportFound = path
        .getAllPrevSiblings()
        .concat(path.getAllNextSiblings())
        .find(function (path) {
        return t.isImportDeclaration(path.node) && path.node.source.value === runtimeImportModuleName;
    });
    if (runtimeImportFound) {
        /**
         * Get local import name instead of imported name to handle scenario when
         * import specifier is imported as named and normal both.
         *
         * eg. import { CC as CompiledRoot, ax, CC, CS } from '@compiled/react/runtime';
         * In above example `CC` is used both as `CompiledRoot` and `CC`.
         */
        var localImportNames_1 = runtimeImportFound
            .get('specifiers')
            .map(function (specifier) { return specifier.node.local.name; });
        runtimeImportNames.forEach(function (runtimeImportName) {
            // Avoids duplicate imports from being appended if already present
            if (!localImportNames_1.includes(runtimeImportName)) {
                runtimeImportFound.pushContainer('specifiers', ast_builders_1.importSpecifier(runtimeImportName));
            }
        });
    }
    else {
        // Add the runtime entrypoint module
        path.insertBefore(t.importDeclaration(runtimeImportNames.map(function (runtimeImportName) { return ast_builders_1.importSpecifier(runtimeImportName); }), t.stringLiteral(runtimeImportModuleName)));
    }
};
exports.default = helper_plugin_utils_1.declare(function (api) {
    api.assertVersion(7);
    return {
        name: pkgJson.name,
        inherits: plugin_syntax_jsx_1.default,
        pre: function () {
            this.sheets = {};
            cache.initialize(this.opts);
            this.cache = cache;
        },
        visitor: {
            Program: {
                exit: function (path, state) {
                    if (!state.compiledImports) {
                        return;
                    }
                    var _a = state.opts.importReact, shouldImportReact = _a === void 0 ? true : _a;
                    if (shouldImportReact && !path.scope.getBinding('React')) {
                        // React is missing - add it in at the last moment!
                        path.unshiftContainer('body', template_1.default.ast("import * as React from 'react'"));
                    }
                    if (state.compiledImports.styled && !path.scope.getBinding('forwardRef')) {
                        // forwardRef is missing - add it in at the last moment!
                        path.unshiftContainer('body', template_1.default.ast("import { forwardRef } from 'react'"));
                    }
                    var version = process.env.TEST_PKG_VERSION || pkgJson.version;
                    path.addComment('leading', " " + parseFilename(state.filename) + " generated by " + pkgJson.name + " v" + version + " ");
                    // Add a line break the comment
                    path.unshiftContainer('body', t.noop());
                },
            },
            ImportDeclaration: function (path, state) {
                if (path.node.source.value !== '@compiled/react') {
                    return;
                }
                // The presence of the module enables CSS prop
                state.compiledImports = {};
                // Go through each import and enable each found API
                path.get('specifiers').forEach(function (specifier) {
                    if (!state.compiledImports || !specifier.isImportSpecifier()) {
                        // Bail out early
                        return;
                    }
                    ['styled', 'ClassNames'].forEach(function (apiName) {
                        var _a, _b;
                        if (state.compiledImports &&
                            t.isIdentifier((_a = specifier.node) === null || _a === void 0 ? void 0 : _a.imported) &&
                            ((_b = specifier.node) === null || _b === void 0 ? void 0 : _b.imported.name) === apiName) {
                            // Enable the API with the local name
                            state.compiledImports[apiName] = specifier.node.local.name;
                            // Remove specifier
                            specifier.remove();
                        }
                    });
                });
                appendRuntimeImports(path);
                if (path.node.specifiers.length === 0) {
                    // No more imports - remove the whole lot!
                    path.remove();
                }
            },
            TaggedTemplateExpression: function (path, state) {
                var _a;
                if (!((_a = state.compiledImports) === null || _a === void 0 ? void 0 : _a.styled)) {
                    return;
                }
                styled_1.visitStyledPath(path, { state: state, parentPath: path });
            },
            CallExpression: function (path, state) {
                if (!state.compiledImports) {
                    return;
                }
                styled_1.visitStyledPath(path, { state: state, parentPath: path });
            },
            JSXElement: function (path, state) {
                var _a;
                if (!((_a = state.compiledImports) === null || _a === void 0 ? void 0 : _a.ClassNames)) {
                    return;
                }
                class_names_1.visitClassNamesPath(path, { state: state, parentPath: path });
            },
            JSXOpeningElement: function (path, state) {
                if (!state.compiledImports) {
                    return;
                }
                css_prop_1.visitCssPropPath(path, { state: state, parentPath: path });
            },
        },
    };
});
//# sourceMappingURL=index.js.map