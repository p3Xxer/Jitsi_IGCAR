"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitStyledPath = void 0;
var t = __importStar(require("@babel/types"));
var ast_builders_1 = require("../utils/ast-builders");
var css_builders_1 = require("../utils/css-builders");
var createStyledDataPair = function (_a) {
    var tagName = _a.tagName, tagType = _a.tagType, cssNode = _a.cssNode;
    return ({
        tag: {
            name: tagName,
            type: tagType,
        },
        cssNode: cssNode,
    });
};
var extractStyledDataFromTemplateLiteral = function (node, meta) {
    var _a, _b;
    if (t.isMemberExpression(node.tag) &&
        t.isIdentifier(node.tag.object) &&
        node.tag.object.name === ((_a = meta.state.compiledImports) === null || _a === void 0 ? void 0 : _a.styled) &&
        t.isIdentifier(node.tag.property)) {
        var tagName = node.tag.property.name;
        var cssNode = node.quasi;
        return createStyledDataPair({ tagName: tagName, tagType: 'InBuiltComponent', cssNode: cssNode });
    }
    if (t.isCallExpression(node.tag) &&
        t.isIdentifier(node.tag.callee) &&
        node.tag.callee.name === ((_b = meta.state.compiledImports) === null || _b === void 0 ? void 0 : _b.styled) &&
        t.isIdentifier(node.tag.arguments[0])) {
        var tagName = node.tag.arguments[0].name;
        var cssNode = node.quasi;
        return createStyledDataPair({ tagName: tagName, tagType: 'UserDefinedComponent', cssNode: cssNode });
    }
    return undefined;
};
var extractStyledDataFromObjectLiteral = function (node, meta) {
    var _a, _b;
    if (t.isMemberExpression(node.callee) &&
        t.isIdentifier(node.callee.object) &&
        node.callee.object.name === ((_a = meta.state.compiledImports) === null || _a === void 0 ? void 0 : _a.styled) &&
        t.isExpression(node.arguments[0]) &&
        t.isIdentifier(node.callee.property)) {
        var tagName = node.callee.property.name;
        var cssNode = node.arguments;
        return createStyledDataPair({ tagName: tagName, tagType: 'InBuiltComponent', cssNode: cssNode });
    }
    if (t.isCallExpression(node.callee) &&
        t.isIdentifier(node.callee.callee) &&
        node.callee.callee.name === ((_b = meta.state.compiledImports) === null || _b === void 0 ? void 0 : _b.styled) &&
        t.isExpression(node.arguments[0]) &&
        t.isIdentifier(node.callee.arguments[0])) {
        var tagName = node.callee.arguments[0].name;
        var cssNode = node.arguments;
        return createStyledDataPair({ tagName: tagName, tagType: 'UserDefinedComponent', cssNode: cssNode });
    }
    return undefined;
};
/**
 * Interrogates `node` and returns styled data if any were found.
 * @param node
 */
var extractStyledDataFromNode = function (node, meta) {
    if (t.isTaggedTemplateExpression(node)) {
        return extractStyledDataFromTemplateLiteral(node, meta);
    }
    if (t.isCallExpression(node)) {
        return extractStyledDataFromObjectLiteral(node, meta);
    }
    return undefined;
};
/**
 * Takes a styled tagged template or call expression and then transforms it to a compiled component.
 *
 * `styled.div({})`
 *
 * @param path Babel path - expects to be a tagged template or call expression.
 * @param state Babel state - should house options and meta data used during the transformation.
 */
var visitStyledPath = function (path, meta) {
    var styledData = extractStyledDataFromNode(path.node, meta);
    if (!styledData) {
        // We didn't find a node we're interested in - bail out!
        return;
    }
    var cssOutput = css_builders_1.buildCss(styledData.cssNode, meta);
    path.replaceWith(ast_builders_1.buildStyledComponent(styledData.tag, cssOutput, meta));
};
exports.visitStyledPath = visitStyledPath;
//# sourceMappingURL=index.js.map