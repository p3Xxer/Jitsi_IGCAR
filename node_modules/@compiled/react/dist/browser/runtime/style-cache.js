import * as React from 'react';
import { createContext, useContext } from 'react';
import { isNodeEnvironment } from './is-node';
/**
 * Cache to hold already used styles.
 * React Context on the server - singleton object on the client.
 */
var Cache = false ? createContext(null) : {};
if (!false) {
    /**
     * Iterates through all found style elements generated when server side rendering.
     *
     * @param cb
     */
    var ssrStyles = document.querySelectorAll('style[data-cmpld]');
    for (var i = 0; i < ssrStyles.length; i++) {
        // Move all found server-side rendered style elements to the head before React hydration happens.
        document.head.appendChild(ssrStyles[i]);
    }
}
/**
 * Hook using the cache created on the server or client.
 */
export var useCache = function () {
    if (false) {
        // On the server we use React Context to we don't leak the cache between SSR calls.
        // During runtime this hook isn't conditionally called - it is at build time that the flow gets decided.
        // eslint-disable-next-line react-hooks/rules-of-hooks
        return useContext(Cache) || {};
    }
    // On the client we use the object singleton.
    return Cache;
};
/**
 * On the server this ensures the minimal amount of styles will be rendered
 * safely using React Context.
 *
 * On the browser this turns into a fragment with no React Context.
 */
var StyleCacheProvider = function (props) {
    if (false) {
        // This code path isn't conditionally called at build time - safe to ignore.
        // eslint-disable-next-line react-hooks/rules-of-hooks
        var inserted = useCache();
        return React.createElement(Cache.Provider, { value: inserted }, props.children);
    }
    return props.children;
};
export default StyleCacheProvider;
//# sourceMappingURL=style-cache.js.map