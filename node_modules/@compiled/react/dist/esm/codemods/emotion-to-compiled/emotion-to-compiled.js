var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import { COMPILED_IMPORT_PATH } from '../constants';
import { hasImportDeclaration, getImportDeclarationCollection, findImportSpecifierName, addCommentForUnresolvedImportSpecifiers, addReactIdentifier, convertDefaultImportToNamedImport, replaceImportDeclaration, mergeImportSpecifiersAlongWithTheirComments, addCommentBefore, } from '../codemods-helpers';
var imports = {
    compiledStyledImportName: 'styled',
    emotionStyledPackageName: '@emotion/styled',
    emotionCoreJSXPragma: '@jsx jsx',
    emotionCoreImportNames: { jsx: 'jsx', css: 'css', ClassNames: 'ClassNames' },
    emotionCorePackageName: '@emotion/core',
};
var removeEmotionCoreJSXPragma = function (j, collection) {
    var commentCollection = collection.find(j.Comment);
    commentCollection.forEach(function (commentPath) {
        var commentBlockCollection = j(commentPath).filter(function (commentBlockPath) {
            return commentBlockPath.value.value.includes(imports.emotionCoreJSXPragma);
        });
        commentBlockCollection.forEach(function (commentBlockPath) {
            j(commentBlockPath).remove();
            addReactIdentifier({ j: j, collection: collection });
        });
    });
};
var replaceEmotionCoreCSSTaggedTemplateExpression = function (j, collection) {
    var importDeclarationCollection = getImportDeclarationCollection({
        j: j,
        collection: collection,
        importPath: imports.emotionCorePackageName,
    });
    var name = findImportSpecifierName({
        j: j,
        importDeclarationCollection: importDeclarationCollection,
        importName: imports.emotionCoreImportNames.css,
    });
    if (name == null) {
        return;
    }
    collection
        .find(j.TaggedTemplateExpression)
        .filter(function (taggedTemplateExpressionPath) {
        return j(taggedTemplateExpressionPath)
            .find(j.Identifier)
            .some(function (identifierPath) { return identifierPath.node.name === name; });
    })
        .forEach(function (taggedTemplateExpressionPath) {
        var quasi = taggedTemplateExpressionPath.node.quasi;
        if (quasi) {
            j(taggedTemplateExpressionPath).replaceWith([quasi]);
        }
    });
};
var handleClassNamesCXBehavior = function (j, objectPattern) {
    var cxIdentifierName = 'cx';
    var axIdentifierName = 'ax';
    var compiledRuntimePackageName = COMPILED_IMPORT_PATH + "/runtime";
    var cxObjectPropertyCollection = j(objectPattern)
        .find(j.ObjectProperty)
        .filter(function (objectPropertyPath) {
        return objectPropertyPath.node.key.type === 'Identifier' &&
            objectPropertyPath.node.key.name === cxIdentifierName;
    });
    cxObjectPropertyCollection.forEach(function (cxObjectPropertyPath) {
        addCommentBefore({
            j: j,
            collection: j(cxObjectPropertyPath.node),
            message: "Please replace \"" + cxIdentifierName + "\" with \"" + axIdentifierName + "\" from \"" + compiledRuntimePackageName + "\".\n      Usage: import { " + axIdentifierName + " } from '" + compiledRuntimePackageName + "';\n\n      NOTE: Both \"" + cxIdentifierName + "\" and \"" + axIdentifierName + "\" have some differences, so we have not replaced its usage.\n      Please check the docs for \"" + axIdentifierName + "\" usage.\n\n      In future, we will expose \"" + axIdentifierName + "\" directly from \"" + imports.emotionCoreImportNames.ClassNames + "\" props.\n\n      Issue tracked on Github: https://github.com/atlassian-labs/compiled/issues/373",
        });
    });
};
var handleClassNamesStyleBehavior = function (j, objectPattern) {
    var styleIdentifierName = 'style';
    var hasStyleObjectProperty = j(objectPattern)
        .find(j.ObjectProperty)
        .some(function (objectPropertyPath) {
        return objectPropertyPath.node.key.type === 'Identifier' &&
            objectPropertyPath.node.key.name === styleIdentifierName;
    });
    if (!hasStyleObjectProperty) {
        var styleObjectProperty = j.objectProperty(j.identifier(styleIdentifierName), j.identifier(styleIdentifierName));
        objectPattern.properties.push(styleObjectProperty);
        addCommentBefore({
            j: j,
            collection: j(styleObjectProperty),
            message: "We have exported \"" + styleIdentifierName + "\" from \"" + imports.emotionCoreImportNames.ClassNames + "\" props.\n      If you are using dynamic declarations, make sure to set the \"" + styleIdentifierName + "\"\n      prop otherwise remove it.",
        });
    }
};
var handleClassNamesBehavior = function (j, collection) {
    var importDeclarationCollection = getImportDeclarationCollection({
        j: j,
        collection: collection,
        importPath: imports.emotionCorePackageName,
    });
    var name = findImportSpecifierName({
        j: j,
        importDeclarationCollection: importDeclarationCollection,
        importName: imports.emotionCoreImportNames.ClassNames,
    });
    if (name == null) {
        return;
    }
    collection
        .find(j.JSXElement)
        .filter(function (jsxElementPath) {
        return j(jsxElementPath)
            .find(j.JSXIdentifier)
            .some(function (jsxIdentifierPath) { return jsxIdentifierPath.node.name === name; });
    })
        .find(j.JSXExpressionContainer)
        .forEach(function (jsxExpressionContainer) {
        var expression = jsxExpressionContainer.node.expression;
        if (expression.type === 'FunctionExpression' ||
            expression.type === 'ArrowFunctionExpression') {
            if (expression.params.length && expression.params[0].type === 'ObjectPattern') {
                var objectPattern = expression.params[0];
                handleClassNamesStyleBehavior(j, objectPattern);
                handleClassNamesCXBehavior(j, objectPattern);
            }
        }
    });
};
var mergeCompiledImportSpecifiers = function (j, collection) {
    var allowedCompiledNames = __spreadArrays([
        imports.compiledStyledImportName
    ], Object.values(imports.emotionCoreImportNames)).filter(function (name) {
        return ![imports.emotionCoreImportNames.jsx, imports.emotionCoreImportNames.css].includes(name);
    });
    mergeImportSpecifiersAlongWithTheirComments({
        j: j,
        collection: collection,
        filter: function (name) { return !!(name && allowedCompiledNames.includes(name)); },
    });
};
var transformer = function (fileInfo, _a, options) {
    var j = _a.jscodeshift;
    var source = fileInfo.source;
    var collection = j(source);
    var hasEmotionCoreImportDeclaration = hasImportDeclaration({
        j: j,
        collection: collection,
        importPath: imports.emotionCorePackageName,
    });
    var hasEmotionStyledImportDeclaration = hasImportDeclaration({
        j: j,
        collection: collection,
        importPath: imports.emotionStyledPackageName,
    });
    if (!hasEmotionCoreImportDeclaration && !hasEmotionStyledImportDeclaration) {
        return source;
    }
    if (hasEmotionStyledImportDeclaration) {
        convertDefaultImportToNamedImport({
            j: j,
            collection: collection,
            importPath: imports.emotionStyledPackageName,
            namedImport: imports.compiledStyledImportName,
        });
    }
    if (hasEmotionCoreImportDeclaration) {
        removeEmotionCoreJSXPragma(j, collection);
        addCommentForUnresolvedImportSpecifiers({
            j: j,
            collection: collection,
            importPath: imports.emotionCorePackageName,
            allowedImportSpecifierNames: Object.values(imports.emotionCoreImportNames),
        });
        replaceEmotionCoreCSSTaggedTemplateExpression(j, collection);
        handleClassNamesBehavior(j, collection);
        replaceImportDeclaration({ j: j, collection: collection, importPath: imports.emotionCorePackageName });
    }
    mergeCompiledImportSpecifiers(j, collection);
    return collection.toSource(options.printOptions || { quote: 'single' });
};
export default transformer;
//# sourceMappingURL=emotion-to-compiled.js.map