import { COMPILED_IMPORT_PATH, REACT_IMPORT_PATH, REACT_IMPORT_NAME } from './constants';
export var getImportDeclarationCollection = function (_a) {
    var j = _a.j, collection = _a.collection, importPath = _a.importPath;
    var found = collection
        .find(j.ImportDeclaration)
        .filter(function (importDeclarationPath) { return importDeclarationPath.node.source.value === importPath; });
    return found;
};
export var hasImportDeclaration = function (_a) {
    var j = _a.j, collection = _a.collection, importPath = _a.importPath;
    var result = getImportDeclarationCollection({
        j: j,
        collection: collection,
        importPath: importPath,
    });
    return result.length > 0;
};
export var getImportDefaultSpecifierName = function (importDefaultSpecifierCollection) {
    var name = importDefaultSpecifierCollection.nodes()[0].local.name;
    if (!name) {
        throw new Error('Name should exist.');
    }
    return name;
};
export var getImportSpecifierName = function (importSpecifierCollection) { return importSpecifierCollection.nodes()[0].local.name; };
export var getAllImportSpecifiers = function (_a) {
    var j = _a.j, importDeclarationCollection = _a.importDeclarationCollection;
    var importSpecifiersImportedNodes = [];
    importDeclarationCollection.find(j.ImportSpecifier).forEach(function (importSpecifierPath) {
        var node = importSpecifierPath.node.imported;
        if (node) {
            importSpecifiersImportedNodes.push(node);
        }
    });
    return importSpecifiersImportedNodes;
};
export var findImportSpecifierName = function (_a) {
    var j = _a.j, importDeclarationCollection = _a.importDeclarationCollection, importName = _a.importName;
    var importSpecifierCollection = importDeclarationCollection
        .find(j.ImportSpecifier)
        .filter(function (importSpecifierPath) { return importSpecifierPath.node.imported.name === importName; });
    if (importSpecifierCollection.length === 0) {
        return null;
    }
    return getImportSpecifierName(importSpecifierCollection);
};
export var convertDefaultImportToNamedImport = function (_a) {
    var j = _a.j, collection = _a.collection, importPath = _a.importPath, namedImport = _a.namedImport;
    var importDeclarationCollection = getImportDeclarationCollection({
        j: j,
        collection: collection,
        importPath: importPath,
    });
    importDeclarationCollection.forEach(function (importDeclarationPath) {
        var importDefaultSpecifierCollection = j(importDeclarationPath).find(j.ImportDefaultSpecifier);
        if (importDefaultSpecifierCollection.length > 0) {
            var oldNode = importDeclarationPath.node;
            var comments = oldNode.comments;
            j(importDeclarationPath).replaceWith([
                j.importDeclaration([
                    j.importSpecifier(j.identifier(namedImport), j.identifier(getImportDefaultSpecifierName(importDefaultSpecifierCollection))),
                ], j.literal(COMPILED_IMPORT_PATH)),
            ]);
            var newNode = importDeclarationPath.node;
            if (newNode !== oldNode) {
                newNode.comments = comments;
            }
        }
    });
};
// not replacing newlines (which \s does)
var spacesAndTabs = /[ \t]{2,}/g;
var lineStartWithSpaces = /^[ \t]*/gm;
var clean = function (value) {
    return value
        .replace(spacesAndTabs, ' ')
        .replace(lineStartWithSpaces, '')
        // using .trim() to clear the any newlines before the first text and after last text
        .trim();
};
export var addCommentBefore = function (_a) {
    var j = _a.j, collection = _a.collection, message = _a.message;
    var content = " TODO(" + COMPILED_IMPORT_PATH + " codemod): " + clean(message) + " ";
    collection.forEach(function (path) {
        path.value.comments = path.value.comments || [];
        var exists = path.value.comments.find(function (comment) { return comment.value === content; });
        // avoiding duplicates of the same comment
        if (exists) {
            return;
        }
        path.value.comments.push(j.commentBlock(content));
    });
};
export var addCommentToStartOfFile = function (_a) {
    var j = _a.j, collection = _a.collection, message = _a.message;
    addCommentBefore({
        j: j,
        collection: collection.find(j.Program),
        message: message,
    });
};
export var addCommentForUnresolvedImportSpecifiers = function (_a) {
    var j = _a.j, collection = _a.collection, importPath = _a.importPath, allowedImportSpecifierNames = _a.allowedImportSpecifierNames;
    var importDeclarationCollection = getImportDeclarationCollection({
        j: j,
        collection: collection,
        importPath: importPath,
    });
    var importSpecifiers = getAllImportSpecifiers({
        j: j,
        importDeclarationCollection: importDeclarationCollection,
    });
    importSpecifiers
        .filter(function (identifierPath) { return !allowedImportSpecifierNames.includes(identifierPath.name); })
        .forEach(function (importSpecifierPath) {
        addCommentToStartOfFile({
            j: j,
            collection: collection,
            message: "\"" + importSpecifierPath.name + "\" is not exported from \"" + COMPILED_IMPORT_PATH + "\" at the moment. Please find an alternative for it.",
        });
    });
};
export var addReactIdentifier = function (_a) {
    var j = _a.j, collection = _a.collection;
    var hasReactImportDeclaration = hasImportDeclaration({
        j: j,
        collection: collection,
        importPath: REACT_IMPORT_PATH,
    });
    if (!hasReactImportDeclaration) {
        collection.find(j.Program).forEach(function (programPath) {
            programPath.node.body.unshift(j.importDeclaration([j.importNamespaceSpecifier(j.identifier(REACT_IMPORT_NAME))], j.literal(REACT_IMPORT_PATH)));
        });
    }
    else {
        var importDeclarationCollection = getImportDeclarationCollection({
            j: j,
            collection: collection,
            importPath: REACT_IMPORT_PATH,
        });
        importDeclarationCollection.forEach(function (importDeclarationPath) {
            var importDefaultSpecifierCollection = j(importDeclarationPath).find(j.ImportDefaultSpecifier);
            var importNamespaceSpecifierCollection = j(importDeclarationPath).find(j.ImportNamespaceSpecifier);
            var hasNoDefaultReactImportDeclaration = importDefaultSpecifierCollection.length === 0;
            var hasNoNamespaceReactImportDeclaration = importNamespaceSpecifierCollection.length === 0;
            if (hasNoDefaultReactImportDeclaration && hasNoNamespaceReactImportDeclaration) {
                importDeclarationPath.node.specifiers.unshift(j.importDefaultSpecifier(j.identifier(REACT_IMPORT_NAME)));
            }
        });
    }
};
export var replaceImportDeclaration = function (_a) {
    var j = _a.j, collection = _a.collection, importPath = _a.importPath;
    var importDeclarationCollection = getImportDeclarationCollection({
        j: j,
        collection: collection,
        importPath: importPath,
    });
    importDeclarationCollection.forEach(function (importDeclarationPath) {
        importDeclarationPath.node.source.value = COMPILED_IMPORT_PATH;
    });
};
export var mergeImportSpecifiersAlongWithTheirComments = function (_a) {
    var j = _a.j, collection = _a.collection, _b = _a.filter, filter = _b === void 0 ? function (_) { return true; } : _b;
    var importDeclarationCollection = getImportDeclarationCollection({
        j: j,
        collection: collection,
        importPath: COMPILED_IMPORT_PATH,
    });
    var importSpecifiers = [];
    importDeclarationCollection
        .find(j.ImportSpecifier)
        .filter(function (importSpecifierPath) { return filter(importSpecifierPath.node.imported.name); })
        .forEach(function (importSpecifierPath) {
        importSpecifiers.push(importSpecifierPath.node);
    });
    var importDeclarationCollectionLength = importDeclarationCollection.length;
    var importDeclarationComments = [];
    importDeclarationCollection.forEach(function (importDeclarationPath, index) {
        var oldNode = importDeclarationPath.node;
        var comments = oldNode.comments;
        if (comments) {
            importDeclarationComments.push.apply(importDeclarationComments, comments);
        }
        if (index === importDeclarationCollectionLength - 1) {
            j(importDeclarationPath).replaceWith([
                j.importDeclaration(importSpecifiers, j.literal(COMPILED_IMPORT_PATH)),
            ]);
            var newNode = importDeclarationPath.node;
            if (newNode !== oldNode) {
                newNode.comments = importDeclarationComments;
            }
        }
        else {
            j(importDeclarationPath).remove();
        }
    });
};
//# sourceMappingURL=codemods-helpers.js.map