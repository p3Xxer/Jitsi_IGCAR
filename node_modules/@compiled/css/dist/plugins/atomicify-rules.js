"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.atomicifyRules = void 0;
var postcss_1 = require("postcss");
var utils_1 = require("@compiled/utils");
/**
 * Returns an atomic rule class name using this form:
 *
 * ```
 * "_{atrulesselectorspropertyname}{propertyvalueimportant}"
 * ```
 *
 * Atomic rules are always prepended with an underscore.
 *
 * @param node CSS declaration
 * @param opts AtomicifyOpts
 */
var atomicClassName = function (node, opts) {
    var selectors = opts.selectors ? opts.selectors.join('') : '';
    var group = utils_1.hash("" + opts.atRule + selectors + node.prop).slice(0, 4);
    var value = node.important ? node.value + node.important : node.value;
    var valueHash = utils_1.hash(value).slice(0, 4);
    return "_" + group + valueHash;
};
/**
 * Returns a normalized selector.
 * The primary function is to get rid of white space and to place a nesting selector if one is missing.
 * If the selector already has a nesting selector - we won't do anything to it.
 *
 * ---
 * ASSUMPTION: Nesting and parent orphaned pseudos plugins should run before the atomicify plugin!
 * ---
 *
 * @param selector
 */
var normalizeSelector = function (selector) {
    if (!selector) {
        // Nothing to see here - return early with a nesting selector!
        return '&';
    }
    // We want to build a consistent selector that we will use to generate the group hash.
    // Because of that we trim whitespace.
    var trimmed = selector.trim();
    if (trimmed.indexOf('&') === -1) {
        return "& " + trimmed;
    }
    return trimmed;
};
/**
 * Replaces all instances of a nesting operator `&` with the parent class name.
 *
 * @param selector
 * @param parentClassName
 */
var replaceNestingSelector = function (selector, parentClassName) {
    return selector.replace(/&/g, "." + parentClassName);
};
/**
 * Builds an atomic rule selector.
 *
 * @param node
 */
var buildAtomicSelector = function (node, opts) {
    var selectors = [];
    (opts.selectors || ['']).forEach(function (selector) {
        var normalizedSelector = normalizeSelector(selector);
        var className = atomicClassName(node, __assign(__assign({}, opts), { selectors: [normalizedSelector] }));
        var replacedSelector = replaceNestingSelector(normalizedSelector, className);
        selectors.push(replacedSelector);
        if (opts.callback) {
            opts.callback(className);
        }
    });
    return selectors.join(', ');
};
/**
 * Transforms a declaration into an atomic rule.
 *
 * @param node
 * @param opts
 */
var atomicifyDecl = function (node, opts) {
    var selector = buildAtomicSelector(node, opts);
    var newDecl = postcss_1.decl({ prop: node.prop, value: node.value });
    var newRule = postcss_1.rule({ selector: selector, nodes: [newDecl] });
    // Pass on important flag.
    newDecl.important = node.important;
    // We need to link the new node to a parent else autoprefixer blows up.
    newDecl.parent = newRule;
    newDecl.raws.before = '';
    newRule.parent = opts.parentNode;
    newRule.raws.before = '';
    return newRule;
};
/**
 * Transforms a rule into atomic rules.
 *
 * @param node
 * @param opts
 */
var atomicifyRule = function (node, opts) {
    if (!node.nodes) {
        return [];
    }
    return node.nodes
        .map(function (childNode) {
        if (childNode.type === 'rule') {
            throw childNode.error('Nested rules need to be flattened first - run the "postcss-nested" plugin before this.');
        }
        if (childNode.type !== 'decl') {
            return undefined;
        }
        return atomicifyDecl(childNode, __assign(__assign({}, opts), { selectors: node.selectors }));
    })
        .filter(function (child) { return !!child; });
};
/**
 * Transforms an atrule into atomic rules.
 *
 * @param node
 * @param opts
 */
var atomicifyAtRule = function (node, opts) {
    var children = [];
    var newNode = node.clone({ nodes: children });
    var atRuleLabel = "" + (opts.atRule || '') + node.name + node.params;
    var atRuleOpts = __assign(__assign({}, opts), { parentNode: newNode, atRule: atRuleLabel });
    newNode.parent = opts.parentNode;
    node.each(function (childNode) {
        switch (childNode.type) {
            case 'atrule':
                children.push(atomicifyAtRule(childNode, atRuleOpts));
                break;
            case 'rule':
                atomicifyRule(childNode, atRuleOpts).forEach(function (rule) {
                    children.push(rule);
                });
                break;
            case 'decl':
                children.push(atomicifyDecl(childNode, atRuleOpts));
                break;
            default:
                break;
        }
    });
    return newNode;
};
/**
 * Transforms a style sheet into atomic rules.
 * When passing a `callback` option it will callback with created class names.
 *
 * Preconditions:
 *
 * 1. No nested rules allowed - normalize them with the `parent-orphaned-pseudos` and `nested` plugins first.
 */
exports.atomicifyRules = postcss_1.plugin('atomicify-rules', function (opts) {
    if (opts === void 0) { opts = {}; }
    return function (root) {
        root.each(function (node) {
            switch (node.type) {
                case 'atrule':
                    var supported = ['media', 'supports', 'document'];
                    if (supported.includes(node.name)) {
                        node.replaceWith(atomicifyAtRule(node, opts));
                    }
                    break;
                case 'rule':
                    node.replaceWith(atomicifyRule(node, opts));
                    break;
                case 'decl':
                    node.replaceWith(atomicifyDecl(node, opts));
                    break;
                case 'comment':
                    node.remove();
                    break;
                default:
                    break;
            }
        });
    };
});
//# sourceMappingURL=atomicify-rules.js.map